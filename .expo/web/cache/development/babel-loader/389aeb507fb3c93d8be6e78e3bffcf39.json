{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport NativeReanimatedModule from \"./NativeReanimated\";\nimport { shouldBeUseWeb } from \"./PlatformChecker\";\nimport { registerWorkletStackDetails } from \"./errors\";\nvar USE_STUB_IMPLEMENTATION = shouldBeUseWeb();\nvar _shareableCache = new WeakMap();\nvar _shareableFlag = Symbol('shareable flag');\nvar MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\nfunction isHostObject(value) {\n  return MAGIC_KEY in value;\n}\nexport function registerShareableMapping(shareable, shareableRef) {\n  if (USE_STUB_IMPLEMENTATION) {\n    return;\n  }\n  _shareableCache.set(shareable, shareableRef || _shareableFlag);\n}\nexport function makeShareableCloneRecursive(value) {\n  var shouldPersistRemote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  var type = typeof value;\n  if ((type === 'object' || type === 'function') && value !== null) {\n    var cached = _shareableCache.get(value);\n    if (cached === _shareableFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached;\n    } else {\n      var toAdapt;\n      if (Array.isArray(value)) {\n        toAdapt = value.map(function (element) {\n          return makeShareableCloneRecursive(element);\n        });\n      } else if (type === 'function' && value.__workletHash === undefined) {\n        toAdapt = value;\n      } else if (isHostObject(value)) {\n        toAdapt = value;\n      } else {\n        toAdapt = {};\n        if (value.__workletHash !== undefined) {\n          if (__DEV__) {\n            registerWorkletStackDetails(value.__workletHash, value.__stackDetails);\n            delete value.__stackDetails;\n          }\n          toAdapt.__initData = makeShareableCloneRecursive(value.__initData, true);\n          delete value.__initData;\n        }\n        for (var _ref of Object.entries(value)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n          var key = _ref2[0];\n          var element = _ref2[1];\n          toAdapt[key] = makeShareableCloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        Object.freeze(value);\n      }\n      var adopted = NativeReanimatedModule.makeShareableClone(toAdapt, shouldPersistRemote);\n      _shareableCache.set(value, adopted);\n      _shareableCache.set(adopted, _shareableFlag);\n      return adopted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value, shouldPersistRemote);\n}\nexport function makeShareableCloneOnUIRecursive(value) {\n  'worklet';\n\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  function cloneRecursive(value) {\n    var type = typeof value;\n    if ((type === 'object' || type === 'function') && value !== null) {\n      var toAdapt;\n      if (Array.isArray(value)) {\n        toAdapt = value.map(function (element) {\n          return cloneRecursive(element);\n        });\n      } else {\n        toAdapt = {};\n        for (var _ref3 of Object.entries(value)) {\n          var _ref4 = _slicedToArray(_ref3, 2);\n          var key = _ref4[0];\n          var element = _ref4[1];\n          toAdapt[key] = cloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        Object.freeze(value);\n      }\n      return _makeShareableClone(toAdapt);\n    }\n    return _makeShareableClone(value);\n  }\n  return cloneRecursive(value);\n}\nexport function makeShareable(value) {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  var handle = makeShareableCloneRecursive({\n    __init: function __init() {\n      'worklet';\n\n      return value;\n    }\n  });\n  registerShareableMapping(value, handle);\n  return value;\n}","map":{"version":3,"mappings":"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","names":["NativeReanimatedModule","shouldBeUseWeb","registerWorkletStackDetails","USE_STUB_IMPLEMENTATION","_shareableCache","WeakMap","_shareableFlag","Symbol","MAGIC_KEY","isHostObject","value","registerShareableMapping","shareable","shareableRef","set","makeShareableCloneRecursive","shouldPersistRemote","type","cached","get","undefined","toAdapt","Array","isArray","map","element","__workletHash","__DEV__","__stackDetails","__initData","Object","entries","key","freeze","adopted","makeShareableClone","makeShareableCloneOnUIRecursive","cloneRecursive","_makeShareableClone","makeShareable","handle","__init"],"sources":["shareables.ts"],"sourcesContent":["import NativeReanimatedModule from './NativeReanimated';\nimport { ShareableRef } from './commonTypes';\nimport { shouldBeUseWeb } from './PlatformChecker';\nimport { registerWorkletStackDetails } from './errors';\n\n// for web/chrome debugger/jest environments this file provides a stub implementation\n// where no shareable references are used. Instead, the objects themselves are used\n// instead of shareable references, because of the fact that we don't have to deal with\n// runnning the code on separate VMs.\nconst USE_STUB_IMPLEMENTATION = shouldBeUseWeb();\n\nconst _shareableCache = new WeakMap<\n  Record<string, unknown>,\n  ShareableRef<any> | symbol\n>();\n// the below symbol is used to represent a mapping from the value to itself\n// this is used to allow for a converted shareable to be passed to makeShareableClone\nconst _shareableFlag = Symbol('shareable flag');\n\nconst MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\n\nfunction isHostObject(value: any): boolean {\n  // We could use JSI to determine whether an object is a host object, however\n  // the below workaround works well and is way faster than an additional JSI call.\n  // We use the fact that host objects have broken implementation of `hasOwnProperty`\n  // and hence return true for all `in` checks regardless of the key we ask for.\n  return MAGIC_KEY in value;\n}\n\nexport function registerShareableMapping(\n  shareable: any,\n  shareableRef?: ShareableRef<any>\n): void {\n  if (USE_STUB_IMPLEMENTATION) {\n    return;\n  }\n  _shareableCache.set(shareable, shareableRef || _shareableFlag);\n}\n\nexport function makeShareableCloneRecursive<T>(\n  value: any,\n  shouldPersistRemote = false\n): ShareableRef<T> {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  // This one actually may be worth to be moved to c++, we also need similar logic to run on the UI thread\n  const type = typeof value;\n  if ((type === 'object' || type === 'function') && value !== null) {\n    const cached = _shareableCache.get(value);\n    if (cached === _shareableFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached as ShareableRef<T>;\n    } else {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => makeShareableCloneRecursive(element));\n      } else if (type === 'function' && value.__workletHash === undefined) {\n        // this is a remote function\n        toAdapt = value;\n      } else if (isHostObject(value)) {\n        // for host objects we pass the reference to the object as shareable and\n        // then recreate new host object wrapping the same instance on the UI thread.\n        // there is no point of iterating over keys as we do for regular objects.\n        toAdapt = value;\n      } else {\n        toAdapt = {};\n        if (value.__workletHash !== undefined) {\n          // we are converting a worklet\n          if (__DEV__) {\n            registerWorkletStackDetails(\n              value.__workletHash,\n              value.__stackDetails\n            );\n            delete value.__stackDetails;\n          }\n          // to save on transferring static __initData field of worklet structure\n          // we request shareable value to persist its UI counterpart. This means\n          // that the __initData field that contains long strings represeting the\n          // worklet code, source map, and location, will always be\n          // serialized/deserialized once.\n          toAdapt.__initData = makeShareableCloneRecursive(\n            value.__initData,\n            true\n          );\n          delete value.__initData;\n        }\n\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = makeShareableCloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // we freeze objects that are transformed to shareable. This should help\n        // detect issues when someone modifies data after it's been converted to\n        // shareable. Meaning that they may be doing a faulty assumption in their\n        // code expecting that the updates are going to automatically populate to\n        // the object sent to the UI thread. If the user really wants some objects\n        // to be mutable they should use shared values instead.\n        Object.freeze(value);\n      }\n      const adopted = NativeReanimatedModule.makeShareableClone(\n        toAdapt,\n        shouldPersistRemote\n      );\n      _shareableCache.set(value, adopted);\n      _shareableCache.set(adopted, _shareableFlag);\n      return adopted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value, shouldPersistRemote);\n}\n\nexport function makeShareableCloneOnUIRecursive<T>(value: T): ShareableRef<T> {\n  'worklet';\n  if (USE_STUB_IMPLEMENTATION) {\n    // @ts-ignore web is an interesting place where we don't run a secondary VM on the UI thread\n    // see more details in the comment where USE_STUB_IMPLEMENTATION is defined.\n    return value;\n  }\n  function cloneRecursive<T>(value: T): ShareableRef<T> {\n    const type = typeof value;\n    if ((type === 'object' || type === 'function') && value !== null) {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => cloneRecursive(element));\n      } else {\n        toAdapt = {};\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = cloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // See the reasoning behind freezing in the other comment above.\n        Object.freeze(value);\n      }\n      return _makeShareableClone(toAdapt);\n    }\n    return _makeShareableClone(value);\n  }\n  return cloneRecursive(value);\n}\n\nexport function makeShareable<T>(value: T): T {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  const handle = makeShareableCloneRecursive({\n    __init: () => {\n      'worklet';\n      return value;\n    },\n  });\n  registerShareableMapping(value, handle);\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}