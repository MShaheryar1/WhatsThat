{"ast":null,"code":"import { reportFatalErrorOnJS } from \"./errors\";\nimport NativeReanimatedModule from \"./NativeReanimated\";\nimport { isJest } from \"./PlatformChecker\";\nimport { runOnJS, setupSetImmediate, flushImmediates, runOnUIImmediately } from \"./threads\";\nfunction callGuardDEV(fn) {\n  'worklet';\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  try {\n    fn.apply(void 0, args);\n  } catch (e) {\n    if (global.ErrorUtils) {\n      global.ErrorUtils.reportFatalError(e);\n    } else {\n      throw e;\n    }\n  }\n}\nfunction valueUnpacker(objectToUnpack, category) {\n  'worklet';\n\n  var workletsCache = global.__workletsCache;\n  var handleCache = global.__handleCache;\n  if (workletsCache === undefined) {\n    workletsCache = global.__workletsCache = new Map();\n    handleCache = global.__handleCache = new WeakMap();\n  }\n  var workletHash = objectToUnpack.__workletHash;\n  if (workletHash !== undefined) {\n    var workletFun = workletsCache.get(workletHash);\n    if (workletFun === undefined) {\n      var initData = objectToUnpack.__initData;\n      if (global.evalWithSourceMap) {\n        workletFun = global.evalWithSourceMap('(' + initData.code + '\\n)', initData.location, initData.sourceMap);\n      } else if (global.evalWithSourceUrl) {\n        workletFun = global.evalWithSourceUrl('(' + initData.code + '\\n)', \"worklet_\" + workletHash);\n      } else {\n        workletFun = eval('(' + initData.code + '\\n)');\n      }\n      workletsCache.set(workletHash, workletFun);\n    }\n    var functionInstance = workletFun.bind(objectToUnpack);\n    objectToUnpack._recur = functionInstance;\n    return functionInstance;\n  } else if (objectToUnpack.__init) {\n    var value = handleCache.get(objectToUnpack);\n    if (value === undefined) {\n      value = objectToUnpack.__init();\n      handleCache.set(objectToUnpack, value);\n    }\n    return value;\n  } else if (category === 'RemoteFunction') {\n    var fun = function fun() {\n      throw new Error(\"Tried to synchronously call a non-worklet function on the UI thread.\\n\\nPossible solutions are:\\n  a) If you want to synchronously execute this method, mark it as a worklet\\n  b) If you want to execute this function on the JS thread, wrap it using `runOnJS`\");\n    };\n    fun.__remoteFunction = objectToUnpack;\n    return fun;\n  } else {\n    throw new Error('data type not recognized by unpack method');\n  }\n}\nfunction setupRequestAnimationFrame() {\n  'worklet';\n  var nativeRequestAnimationFrame = global.requestAnimationFrame;\n  var animationFrameCallbacks = [];\n  var lastNativeAnimationFrameTimestamp = -1;\n  global.__flushAnimationFrame = function (frameTimestamp) {\n    var currentCallbacks = animationFrameCallbacks;\n    animationFrameCallbacks = [];\n    currentCallbacks.forEach(function (f) {\n      return f(frameTimestamp);\n    });\n    flushImmediates();\n  };\n  global.requestAnimationFrame = function (callback) {\n    animationFrameCallbacks.push(callback);\n    if (animationFrameCallbacks.length === 1) {\n      nativeRequestAnimationFrame(function (timestamp) {\n        if (lastNativeAnimationFrameTimestamp >= timestamp) {\n          return;\n        }\n        lastNativeAnimationFrameTimestamp = timestamp;\n        global.__frameTimestamp = timestamp;\n        global.__flushAnimationFrame(timestamp);\n        global.__frameTimestamp = undefined;\n      });\n    }\n    return -1;\n  };\n}\nexport function initializeUIRuntime() {\n  NativeReanimatedModule.installCoreFunctions(callGuardDEV, valueUnpacker);\n  var IS_JEST = isJest();\n  if (IS_JEST) {\n    global.requestAnimationFrame = function (callback) {\n      return setTimeout(function () {\n        return callback(performance.now());\n      }, 0);\n    };\n  }\n  var capturableConsole = console;\n  runOnUIImmediately(function () {\n    'worklet';\n    global.ErrorUtils = {\n      reportFatalError: function reportFatalError(error) {\n        runOnJS(reportFatalErrorOnJS)({\n          message: error.message,\n          stack: error.stack\n        });\n      }\n    };\n    global.console = {\n      debug: runOnJS(capturableConsole.debug),\n      log: runOnJS(capturableConsole.log),\n      warn: runOnJS(capturableConsole.warn),\n      error: runOnJS(capturableConsole.error),\n      info: runOnJS(capturableConsole.info)\n    };\n    if (!IS_JEST) {\n      setupSetImmediate();\n      setupRequestAnimationFrame();\n    }\n  })();\n}","map":{"version":3,"mappings":"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","names":["reportFatalErrorOnJS","NativeReanimatedModule","isJest","runOnJS","setupSetImmediate","flushImmediates","runOnUIImmediately","callGuardDEV","fn","args","e","global","ErrorUtils","reportFatalError","valueUnpacker","objectToUnpack","category","workletsCache","__workletsCache","handleCache","__handleCache","undefined","Map","WeakMap","workletHash","__workletHash","workletFun","get","initData","__initData","evalWithSourceMap","code","location","sourceMap","evalWithSourceUrl","eval","set","functionInstance","bind","_recur","__init","value","fun","Error","__remoteFunction","setupRequestAnimationFrame","nativeRequestAnimationFrame","requestAnimationFrame","animationFrameCallbacks","lastNativeAnimationFrameTimestamp","__flushAnimationFrame","frameTimestamp","currentCallbacks","forEach","f","callback","push","length","timestamp","__frameTimestamp","initializeUIRuntime","installCoreFunctions","IS_JEST","setTimeout","performance","now","capturableConsole","console","error","message","stack","debug","log","warn","info"],"sources":["initializers.ts"],"sourcesContent":["import { reportFatalErrorOnJS } from './errors';\nimport NativeReanimatedModule from './NativeReanimated';\nimport { isJest } from './PlatformChecker';\nimport {\n  runOnJS,\n  setupSetImmediate,\n  flushImmediates,\n  runOnUIImmediately,\n} from './threads';\n\n// callGuard is only used with debug builds\nfunction callGuardDEV<T extends Array<any>, U>(\n  fn: (...args: T) => U,\n  ...args: T\n): void {\n  'worklet';\n  try {\n    fn(...args);\n  } catch (e) {\n    if (global.ErrorUtils) {\n      global.ErrorUtils.reportFatalError(e as Error);\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction valueUnpacker(objectToUnpack: any, category?: string): any {\n  'worklet';\n  let workletsCache = global.__workletsCache;\n  let handleCache = global.__handleCache;\n  if (workletsCache === undefined) {\n    // init\n    workletsCache = global.__workletsCache = new Map();\n    handleCache = global.__handleCache = new WeakMap();\n  }\n  const workletHash = objectToUnpack.__workletHash;\n  if (workletHash !== undefined) {\n    let workletFun = workletsCache.get(workletHash);\n    if (workletFun === undefined) {\n      const initData = objectToUnpack.__initData;\n      if (global.evalWithSourceMap) {\n        // if the runtime (hermes only for now) supports loading source maps\n        // we want to use the proper filename for the location as it guarantees\n        // that debugger understands and loads the source code of the file where\n        // the worklet is defined.\n        workletFun = global.evalWithSourceMap(\n          '(' + initData.code + '\\n)',\n          initData.location,\n          initData.sourceMap\n        ) as (...args: any[]) => any;\n      } else if (global.evalWithSourceUrl) {\n        // if the runtime doesn't support loading source maps, in dev mode we\n        // can pass source url when evaluating the worklet. Now, instead of using\n        // the actual file location we use worklet hash, as it the allows us to\n        // properly symbolicate traces (see errors.ts for details)\n        workletFun = global.evalWithSourceUrl(\n          '(' + initData.code + '\\n)',\n          `worklet_${workletHash}`\n        ) as (...args: any[]) => any;\n      } else {\n        // in release we use the regular eval to save on JSI calls\n        // eslint-disable-next-line no-eval\n        workletFun = eval('(' + initData.code + '\\n)') as (\n          ...args: any[]\n        ) => any;\n      }\n      workletsCache.set(workletHash, workletFun);\n    }\n    const functionInstance = workletFun.bind(objectToUnpack);\n    objectToUnpack._recur = functionInstance;\n    return functionInstance;\n  } else if (objectToUnpack.__init) {\n    let value = handleCache!.get(objectToUnpack);\n    if (value === undefined) {\n      value = objectToUnpack.__init();\n      handleCache!.set(objectToUnpack, value);\n    }\n    return value;\n  } else if (category === 'RemoteFunction') {\n    const fun = () => {\n      throw new Error(`Tried to synchronously call a non-worklet function on the UI thread.\n\nPossible solutions are:\n  a) If you want to synchronously execute this method, mark it as a worklet\n  b) If you want to execute this function on the JS thread, wrap it using \\`runOnJS\\``);\n    };\n    fun.__remoteFunction = objectToUnpack;\n    return fun;\n  } else {\n    throw new Error('data type not recognized by unpack method');\n  }\n}\n\nfunction setupRequestAnimationFrame() {\n  'worklet';\n\n  // Jest mocks requestAnimationFrame API and it does not like if that mock gets overridden\n  // so we avoid doing requestAnimationFrame batching in Jest environment.\n  const nativeRequestAnimationFrame = global.requestAnimationFrame;\n\n  let animationFrameCallbacks: Array<(timestamp: number) => void> = [];\n  let lastNativeAnimationFrameTimestamp = -1;\n\n  global.__flushAnimationFrame = (frameTimestamp: number) => {\n    const currentCallbacks = animationFrameCallbacks;\n    animationFrameCallbacks = [];\n    currentCallbacks.forEach((f) => f(frameTimestamp));\n    flushImmediates();\n  };\n\n  global.requestAnimationFrame = (\n    callback: (timestamp: number) => void\n  ): number => {\n    animationFrameCallbacks.push(callback);\n    if (animationFrameCallbacks.length === 1) {\n      // We schedule native requestAnimationFrame only when the first callback\n      // is added and then use it to execute all the enqueued callbacks. Once\n      // the callbacks are run, we clear the array.\n      nativeRequestAnimationFrame((timestamp) => {\n        if (lastNativeAnimationFrameTimestamp >= timestamp) {\n          // Make sure we only execute the callbacks once for a given frame\n          return;\n        }\n        lastNativeAnimationFrameTimestamp = timestamp;\n        global.__frameTimestamp = timestamp;\n        global.__flushAnimationFrame(timestamp);\n        global.__frameTimestamp = undefined;\n      });\n    }\n    // Reanimated currently does not support cancelling callbacks requested with\n    // requestAnimationFrame. We return -1 as identifier which isn't in line\n    // with the spec but it should give users better clue in case they actually\n    // attempt to store the value returned from rAF and use it for cancelling.\n    return -1;\n  };\n}\n\nexport function initializeUIRuntime() {\n  NativeReanimatedModule.installCoreFunctions(callGuardDEV, valueUnpacker);\n\n  const IS_JEST = isJest();\n\n  if (IS_JEST) {\n    // requestAnimationFrame react-native jest's setup is incorrect as it polyfills\n    // the method directly using setTimeout, therefore the callback doesn't get the\n    // expected timestamp as the only argument: https://github.com/facebook/react-native/blob/main/jest/setup.js#L28\n    // We override this setup here to make sure that callbacks get the proper timestamps\n    // when executed. For non-jest environments we define requestAnimationFrame in setupRequestAnimationFrame\n    // @ts-ignore TypeScript uses Node definition for rAF, setTimeout, etc which returns a Timeout object rather than a number\n    global.requestAnimationFrame = (callback: (timestamp: number) => void) => {\n      return setTimeout(() => callback(performance.now()), 0);\n    };\n  }\n\n  const capturableConsole = console;\n  runOnUIImmediately(() => {\n    'worklet';\n    // setup error handler\n    global.ErrorUtils = {\n      reportFatalError: (error: Error) => {\n        runOnJS(reportFatalErrorOnJS)({\n          message: error.message,\n          stack: error.stack,\n        });\n      },\n    };\n\n    // setup console\n    // @ts-ignore TypeScript doesn't like that there are missing methods in console object, but we don't provide all the methods for the UI runtime console version\n    global.console = {\n      debug: runOnJS(capturableConsole.debug),\n      log: runOnJS(capturableConsole.log),\n      warn: runOnJS(capturableConsole.warn),\n      error: runOnJS(capturableConsole.error),\n      info: runOnJS(capturableConsole.info),\n    };\n\n    if (!IS_JEST) {\n      setupSetImmediate();\n      setupRequestAnimationFrame();\n    }\n  })();\n}\n"]},"metadata":{},"sourceType":"module"}