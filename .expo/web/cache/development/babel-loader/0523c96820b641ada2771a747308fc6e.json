{"ast":null,"code":"import { isColor, convertToRGBA, rgbaArrayToRGBAColor, toGammaSpace, toLinearSpace } from \"../Colors\";\nimport NativeReanimatedModule from \"../NativeReanimated\";\nvar IN_STYLE_UPDATER = false;\nexport function initialUpdaterRun(updater) {\n  IN_STYLE_UPDATER = true;\n  var result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\nfunction recognizePrefixSuffix(value) {\n  'worklet';\n\n  if (typeof value === 'string') {\n    var _match$;\n    var match = value.match(/([A-Za-z]*)(-?\\d*\\.?\\d*)([eE][-+]?[0-9]+)?([A-Za-z%]*)/);\n    if (!match) {\n      throw Error(\"Couldn't parse animation value. Check if there isn't any typo.\");\n    }\n    var prefix = match[1];\n    var suffix = match[4];\n    var number = match[2] + ((_match$ = match[3]) != null ? _match$ : '');\n    return {\n      prefix: prefix,\n      suffix: suffix,\n      strippedValue: parseFloat(number)\n    };\n  } else {\n    return {\n      strippedValue: value\n    };\n  }\n}\nfunction decorateAnimation(animation) {\n  'worklet';\n\n  if (animation.isHigherOrder) {\n    return;\n  }\n  var baseOnStart = animation.onStart;\n  var baseOnFrame = animation.onFrame;\n  var animationCopy = Object.assign({}, animation);\n  delete animationCopy.callback;\n  var prefNumberSuffOnStart = function prefNumberSuffOnStart(animation, value, timestamp, previousAnimation) {\n    var _animation$__prefix, _animation$__suffix;\n    var _recognizePrefixSuffi = recognizePrefixSuffix(value),\n      prefix = _recognizePrefixSuffi.prefix,\n      suffix = _recognizePrefixSuffi.suffix,\n      strippedValue = _recognizePrefixSuffi.strippedValue;\n    animation.__prefix = prefix;\n    animation.__suffix = suffix;\n    animation.strippedCurrent = strippedValue;\n    var _recognizePrefixSuffi2 = recognizePrefixSuffix(animation.toValue),\n      strippedToValue = _recognizePrefixSuffi2.strippedValue;\n    animation.current = strippedValue;\n    animation.startValue = strippedValue;\n    animation.toValue = strippedToValue;\n    if (previousAnimation && previousAnimation !== animation) {\n      var _recognizePrefixSuffi3 = recognizePrefixSuffix(previousAnimation.current),\n        paPrefix = _recognizePrefixSuffi3.prefix,\n        paSuffix = _recognizePrefixSuffi3.suffix,\n        paStrippedValue = _recognizePrefixSuffi3.strippedValue;\n      previousAnimation.current = paStrippedValue;\n      previousAnimation.__prefix = paPrefix;\n      previousAnimation.__suffix = paSuffix;\n    }\n    baseOnStart(animation, strippedValue, timestamp, previousAnimation);\n    animation.current = ((_animation$__prefix = animation.__prefix) != null ? _animation$__prefix : '') + animation.current + ((_animation$__suffix = animation.__suffix) != null ? _animation$__suffix : '');\n    if (previousAnimation && previousAnimation !== animation) {\n      var _previousAnimation$__, _previousAnimation$__2;\n      previousAnimation.current = ((_previousAnimation$__ = previousAnimation.__prefix) != null ? _previousAnimation$__ : '') + previousAnimation.current + ((_previousAnimation$__2 = previousAnimation.__suffix) != null ? _previousAnimation$__2 : '');\n    }\n  };\n  var prefNumberSuffOnFrame = function prefNumberSuffOnFrame(animation, timestamp) {\n    var _animation$__prefix2, _animation$__suffix2;\n    animation.current = animation.strippedCurrent;\n    var res = baseOnFrame(animation, timestamp);\n    animation.strippedCurrent = animation.current;\n    animation.current = ((_animation$__prefix2 = animation.__prefix) != null ? _animation$__prefix2 : '') + animation.current + ((_animation$__suffix2 = animation.__suffix) != null ? _animation$__suffix2 : '');\n    return res;\n  };\n  var tab = ['R', 'G', 'B', 'A'];\n  var colorOnStart = function colorOnStart(animation, value, timestamp, previousAnimation) {\n    var RGBAValue;\n    var RGBACurrent;\n    var RGBAToValue;\n    var res = [];\n    if (isColor(value)) {\n      RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n      RGBAValue = toLinearSpace(convertToRGBA(value));\n      if (animation.toValue) {\n        RGBAToValue = toLinearSpace(convertToRGBA(animation.toValue));\n      }\n    }\n    tab.forEach(function (i, index) {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = RGBACurrent[index];\n      animation[i].toValue = RGBAToValue ? RGBAToValue[index] : undefined;\n      animation[i].onStart(animation[i], RGBAValue[index], timestamp, previousAnimation ? previousAnimation[i] : undefined);\n      res.push(animation[i].current);\n    });\n    animation.current = rgbaArrayToRGBAColor(toGammaSpace(res));\n  };\n  var colorOnFrame = function colorOnFrame(animation, timestamp) {\n    var RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n    var res = [];\n    var finished = true;\n    tab.forEach(function (i, index) {\n      animation[i].current = RGBACurrent[index];\n      finished &= animation[i].onFrame(animation[i], timestamp);\n      res.push(animation[i].current);\n    });\n    animation.current = rgbaArrayToRGBAColor(toGammaSpace(res));\n    return finished;\n  };\n  var arrayOnStart = function arrayOnStart(animation, value, timestamp, previousAnimation) {\n    value.forEach(function (v, i) {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = v;\n      animation[i].toValue = animation.toValue[i];\n      animation[i].onStart(animation[i], v, timestamp, previousAnimation ? previousAnimation[i] : undefined);\n    });\n    animation.current = value;\n  };\n  var arrayOnFrame = function arrayOnFrame(animation, timestamp) {\n    var finished = true;\n    animation.current.forEach(function (v, i) {\n      finished &= animation[i].onFrame(animation[i], timestamp);\n      animation.current[i] = animation[i].current;\n    });\n    return finished;\n  };\n  animation.onStart = function (animation, value, timestamp, previousAnimation) {\n    if (isColor(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (Array.isArray(value)) {\n      arrayOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = arrayOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    }\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\nvar IS_NATIVE = NativeReanimatedModule.native;\nexport function defineAnimation(starting, factory) {\n  'worklet';\n\n  if (IN_STYLE_UPDATER) {\n    return starting;\n  }\n  var create = function create() {\n    'worklet';\n\n    var animation = factory();\n    decorateAnimation(animation);\n    return animation;\n  };\n  if (_WORKLET || !IS_NATIVE) {\n    return create();\n  }\n  return create;\n}\nexport function cancelAnimation(sharedValue) {\n  'worklet';\n  sharedValue.value = sharedValue.value;\n}\nexport function withStartValue(startValue, animation) {\n  'worklet';\n\n  return defineAnimation(startValue, function () {\n    'worklet';\n\n    if (!_WORKLET && typeof animation === 'function') {\n      animation = animation();\n    }\n    animation.current = startValue;\n    return animation;\n  });\n}","map":{"version":3,"mappings":"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","names":["isColor","convertToRGBA","rgbaArrayToRGBAColor","toGammaSpace","toLinearSpace","NativeReanimatedModule","IN_STYLE_UPDATER","initialUpdaterRun","updater","result","recognizePrefixSuffix","value","match","Error","prefix","suffix","number","strippedValue","parseFloat","decorateAnimation","animation","isHigherOrder","baseOnStart","onStart","baseOnFrame","onFrame","animationCopy","Object","assign","callback","prefNumberSuffOnStart","timestamp","previousAnimation","__prefix","__suffix","strippedCurrent","toValue","strippedToValue","current","startValue","paPrefix","paSuffix","paStrippedValue","prefNumberSuffOnFrame","res","tab","colorOnStart","RGBAValue","RGBACurrent","RGBAToValue","forEach","i","index","undefined","push","colorOnFrame","finished","arrayOnStart","v","arrayOnFrame","Array","isArray","IS_NATIVE","native","defineAnimation","starting","factory","create","_WORKLET","cancelAnimation","sharedValue","withStartValue"],"sources":["util.ts"],"sourcesContent":["import {\n  HigherOrderAnimation,\n  NextAnimation,\n  DelayAnimation,\n  RepeatAnimation,\n  SequenceAnimation,\n  StyleLayoutAnimation,\n} from './commonTypes';\n/* global _WORKLET */\nimport {\n  ParsedColorArray,\n  isColor,\n  convertToRGBA,\n  rgbaArrayToRGBAColor,\n  toGammaSpace,\n  toLinearSpace,\n} from '../Colors';\n\nimport {\n  AnimatedStyle,\n  SharedValue,\n  AnimatableValue,\n  Animation,\n  AnimationObject,\n  Timestamp,\n} from '../commonTypes';\nimport NativeReanimatedModule from '../NativeReanimated';\n\nlet IN_STYLE_UPDATER = false;\n\nexport type UserUpdater = () => AnimatedStyle;\n\nexport function initialUpdaterRun<T>(updater: () => T): T {\n  IN_STYLE_UPDATER = true;\n  const result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\n\ninterface RecognizedPrefixSuffix {\n  prefix?: string;\n  suffix?: string;\n  strippedValue: number;\n}\n\nfunction recognizePrefixSuffix(value: string | number): RecognizedPrefixSuffix {\n  'worklet';\n  if (typeof value === 'string') {\n    const match = value.match(\n      /([A-Za-z]*)(-?\\d*\\.?\\d*)([eE][-+]?[0-9]+)?([A-Za-z%]*)/\n    );\n    if (!match) {\n      throw Error(\n        \"Couldn't parse animation value. Check if there isn't any typo.\"\n      );\n    }\n    const prefix = match[1];\n    const suffix = match[4];\n    // number with scientific notation\n    const number = match[2] + (match[3] ?? '');\n    return { prefix, suffix, strippedValue: parseFloat(number) };\n  } else {\n    return { strippedValue: value };\n  }\n}\n\nfunction decorateAnimation<T extends AnimationObject | StyleLayoutAnimation>(\n  animation: T\n): void {\n  'worklet';\n  if ((animation as HigherOrderAnimation).isHigherOrder) {\n    return;\n  }\n\n  const baseOnStart = (animation as Animation<AnimationObject>).onStart;\n  const baseOnFrame = (animation as Animation<AnimationObject>).onFrame;\n  const animationCopy = Object.assign({}, animation);\n  delete animationCopy.callback;\n\n  const prefNumberSuffOnStart = (\n    animation: Animation<AnimationObject>,\n    value: string | number,\n    timestamp: number,\n    previousAnimation: Animation<AnimationObject>\n  ) => {\n    // recognize prefix, suffix, and updates stripped value on animation start\n    const { prefix, suffix, strippedValue } = recognizePrefixSuffix(value);\n    animation.__prefix = prefix;\n    animation.__suffix = suffix;\n    animation.strippedCurrent = strippedValue;\n    const { strippedValue: strippedToValue } = recognizePrefixSuffix(\n      animation.toValue as string | number\n    );\n    animation.current = strippedValue;\n    animation.startValue = strippedValue;\n    animation.toValue = strippedToValue;\n    if (previousAnimation && previousAnimation !== animation) {\n      const {\n        prefix: paPrefix,\n        suffix: paSuffix,\n        strippedValue: paStrippedValue,\n      } = recognizePrefixSuffix(previousAnimation.current as string | number);\n      previousAnimation.current = paStrippedValue;\n      previousAnimation.__prefix = paPrefix;\n      previousAnimation.__suffix = paSuffix;\n    }\n\n    baseOnStart(animation, strippedValue, timestamp, previousAnimation);\n\n    animation.current =\n      (animation.__prefix ?? '') +\n      animation.current +\n      (animation.__suffix ?? '');\n\n    if (previousAnimation && previousAnimation !== animation) {\n      previousAnimation.current =\n        (previousAnimation.__prefix ?? '') +\n        previousAnimation.current +\n        (previousAnimation.__suffix ?? '');\n    }\n  };\n  const prefNumberSuffOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: number\n  ) => {\n    animation.current = animation.strippedCurrent;\n    const res = baseOnFrame(animation, timestamp);\n    animation.strippedCurrent = animation.current;\n    animation.current =\n      (animation.__prefix ?? '') +\n      animation.current +\n      (animation.__suffix ?? '');\n    return res;\n  };\n\n  const tab = ['R', 'G', 'B', 'A'];\n  const colorOnStart = (\n    animation: Animation<AnimationObject>,\n    value: string | number,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    let RGBAValue: ParsedColorArray;\n    let RGBACurrent: ParsedColorArray;\n    let RGBAToValue: ParsedColorArray;\n    const res: Array<number> = [];\n    if (isColor(value)) {\n      RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n      RGBAValue = toLinearSpace(convertToRGBA(value));\n      if (animation.toValue) {\n        RGBAToValue = toLinearSpace(convertToRGBA(animation.toValue));\n      }\n    }\n    tab.forEach((i, index) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = RGBACurrent[index];\n      animation[i].toValue = RGBAToValue ? RGBAToValue[index] : undefined;\n      animation[i].onStart(\n        animation[i],\n        RGBAValue[index],\n        timestamp,\n        previousAnimation ? previousAnimation[i] : undefined\n      );\n      res.push(animation[i].current);\n    });\n\n    animation.current = rgbaArrayToRGBAColor(\n      toGammaSpace(res as ParsedColorArray)\n    );\n  };\n\n  const colorOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    const RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n    const res: Array<number> = [];\n    let finished = true;\n    tab.forEach((i, index) => {\n      animation[i].current = RGBACurrent[index];\n      // @ts-ignore: disable-next-line\n      finished &= animation[i].onFrame(animation[i], timestamp);\n      res.push(animation[i].current);\n    });\n\n    animation.current = rgbaArrayToRGBAColor(\n      toGammaSpace(res as ParsedColorArray)\n    );\n    return finished;\n  };\n\n  const arrayOnStart = (\n    animation: Animation<AnimationObject>,\n    value: Array<number>,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    value.forEach((v, i) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = v;\n      animation[i].toValue = (animation.toValue as Array<number>)[i];\n      animation[i].onStart(\n        animation[i],\n        v,\n        timestamp,\n        previousAnimation ? previousAnimation[i] : undefined\n      );\n    });\n\n    animation.current = value;\n  };\n\n  const arrayOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    let finished = true;\n    (animation.current as Array<number>).forEach((v, i) => {\n      // @ts-ignore: disable-next-line\n      finished &= animation[i].onFrame(animation[i], timestamp);\n      (animation.current as Array<number>)[i] = animation[i].current;\n    });\n\n    return finished;\n  };\n\n  animation.onStart = (\n    animation: Animation<AnimationObject>,\n    value: number,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ) => {\n    if (isColor(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (Array.isArray(value)) {\n      arrayOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = arrayOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    }\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\n\ntype AnimationToDecoration<T extends AnimationObject | StyleLayoutAnimation> =\n  T extends StyleLayoutAnimation\n    ? Record<string, unknown>\n    : T extends DelayAnimation\n    ? NextAnimation<DelayAnimation>\n    : T extends RepeatAnimation\n    ? NextAnimation<RepeatAnimation>\n    : T extends SequenceAnimation\n    ? NextAnimation<SequenceAnimation>\n    : AnimatableValue | T;\n\nconst IS_NATIVE = NativeReanimatedModule.native;\n\nexport function defineAnimation<\n  T extends AnimationObject | StyleLayoutAnimation\n>(starting: AnimationToDecoration<T>, factory: () => T): T {\n  'worklet';\n  if (IN_STYLE_UPDATER) {\n    return starting as T;\n  }\n  const create = () => {\n    'worklet';\n    const animation = factory();\n    decorateAnimation<T>(animation);\n    return animation;\n  };\n\n  if (_WORKLET || !IS_NATIVE) {\n    return create();\n  }\n  // @ts-ignore: eslint-disable-line\n  return create;\n}\n\nexport function cancelAnimation<T>(sharedValue: SharedValue<T>): void {\n  'worklet';\n  // setting the current value cancels the animation if one is currently running\n  sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign\n}\n\n// TODO it should work only if there was no animation before.\nexport function withStartValue(\n  startValue: AnimatableValue,\n  animation: NextAnimation<AnimationObject>\n): Animation<AnimationObject> {\n  'worklet';\n  return defineAnimation(startValue, () => {\n    'worklet';\n    if (!_WORKLET && typeof animation === 'function') {\n      animation = animation();\n    }\n    (animation as Animation<AnimationObject>).current = startValue;\n    return animation as Animation<AnimationObject>;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}