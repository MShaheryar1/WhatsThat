{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport NativeReanimatedModule from \"./NativeReanimated\";\nimport { isJest, shouldBeUseWeb } from \"./PlatformChecker\";\nimport { makeShareableCloneOnUIRecursive, makeShareableCloneRecursive } from \"./shareables\";\nvar IS_JEST = isJest();\nvar IS_WEB = shouldBeUseWeb();\nvar _runOnUIQueue = [];\nexport function setupSetImmediate() {\n  'worklet';\n\n  var immediateCallbacks = [];\n  global.setImmediate = function (callback) {\n    immediateCallbacks.push(callback);\n    return -1;\n  };\n  global.__flushImmediates = function () {\n    for (var index = 0; index < immediateCallbacks.length; index += 1) {\n      immediateCallbacks[index]();\n    }\n    immediateCallbacks = [];\n  };\n}\nfunction flushImmediatesOnUIThread() {\n  'worklet';\n\n  global.__flushImmediates();\n}\nexport var flushImmediates = shouldBeUseWeb() ? function () {} : flushImmediatesOnUIThread;\nexport function runOnUI(worklet) {\n  if (__DEV__ && !IS_WEB && worklet.__workletHash === undefined) {\n    throw new Error('runOnUI() can only be used on worklets');\n  }\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (IS_JEST) {\n      NativeReanimatedModule.scheduleOnUI(makeShareableCloneRecursive(function () {\n        'worklet';\n\n        worklet.apply(void 0, args);\n      }));\n      return;\n    }\n    _runOnUIQueue.push([worklet, args]);\n    if (_runOnUIQueue.length === 1) {\n      setImmediate(function () {\n        var queue = _runOnUIQueue;\n        _runOnUIQueue = [];\n        NativeReanimatedModule.scheduleOnUI(makeShareableCloneRecursive(function () {\n          'worklet';\n\n          queue.forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              worklet = _ref2[0],\n              args = _ref2[1];\n            worklet.apply(void 0, _toConsumableArray(args));\n          });\n          flushImmediates();\n        }));\n      });\n    }\n  };\n}\nexport function runOnUIImmediately(worklet) {\n  if (__DEV__ && !IS_WEB && worklet.__workletHash === undefined) {\n    throw new Error('runOnUI() can only be used on worklets');\n  }\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    NativeReanimatedModule.scheduleOnUI(makeShareableCloneRecursive(function () {\n      'worklet';\n\n      worklet.apply(void 0, args);\n    }));\n  };\n}\nif (__DEV__) {\n  try {\n    runOnUI(function () {\n      'worklet';\n    });\n  } catch (e) {\n    throw new Error('Failed to create a worklet. Did you forget to add Reanimated Babel plugin in babel.config.js? See installation docs at https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/installation#babel-plugin.');\n  }\n}\nexport function runOnJS(fun) {\n  'worklet';\n\n  if (fun.__remoteFunction) {\n    fun = fun.__remoteFunction;\n  }\n  if (!_WORKLET) {\n    return fun;\n  }\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    _scheduleOnJS(fun, args.length > 0 ? makeShareableCloneOnUIRecursive(args) : undefined);\n  };\n}","map":{"version":3,"mappings":"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","names":["NativeReanimatedModule","isJest","shouldBeUseWeb","makeShareableCloneOnUIRecursive","makeShareableCloneRecursive","IS_JEST","IS_WEB","_runOnUIQueue","setupSetImmediate","immediateCallbacks","global","setImmediate","callback","push","__flushImmediates","index","length","flushImmediatesOnUIThread","flushImmediates","runOnUI","worklet","__DEV__","__workletHash","undefined","Error","args","scheduleOnUI","queue","forEach","runOnUIImmediately","e","runOnJS","fun","__remoteFunction","_WORKLET","_scheduleOnJS"],"sources":["threads.ts"],"sourcesContent":["import NativeReanimatedModule from './NativeReanimated';\nimport { isJest, shouldBeUseWeb } from './PlatformChecker';\nimport { ComplexWorkletFunction } from './commonTypes';\nimport {\n  makeShareableCloneOnUIRecursive,\n  makeShareableCloneRecursive,\n} from './shareables';\n\nconst IS_JEST = isJest();\nconst IS_WEB = shouldBeUseWeb();\n\nlet _runOnUIQueue: Array<[ComplexWorkletFunction<any[], any>, any[]]> = [];\n\nexport function setupSetImmediate() {\n  'worklet';\n\n  let immediateCallbacks: Array<() => void> = [];\n\n  // @ts-ignore â€“ typescript expects this to conform to NodeJS definition and expects the return value to be NodeJS.Immediate which is an object and not a number\n  global.setImmediate = (callback: () => void): number => {\n    immediateCallbacks.push(callback);\n    return -1;\n  };\n\n  global.__flushImmediates = () => {\n    for (let index = 0; index < immediateCallbacks.length; index += 1) {\n      // we use classic 'for' loop because the size of the currentTasks array may change while executing some of the callbacks due to setImmediate calls\n      immediateCallbacks[index]();\n    }\n    immediateCallbacks = [];\n  };\n}\n\nfunction flushImmediatesOnUIThread() {\n  'worklet';\n  global.__flushImmediates();\n}\n\nexport const flushImmediates = shouldBeUseWeb()\n  ? () => {\n      // on web flushing is a noop as immediates are handled by the browser\n    }\n  : flushImmediatesOnUIThread;\n\n/**\n * Schedule a worklet to execute on the UI runtime. This method does not schedule the work immediately but instead\n * waits for other worklets to be scheduled within the same JS loop. It uses setImmediate to schedule all the worklets\n * at once making sure they will run within the same frame boundaries on the UI thread.\n */\nexport function runOnUI<A extends any[], R>(\n  worklet: ComplexWorkletFunction<A, R>\n): (...args: A) => void {\n  if (__DEV__ && !IS_WEB && worklet.__workletHash === undefined) {\n    throw new Error('runOnUI() can only be used on worklets');\n  }\n  return (...args) => {\n    if (IS_JEST) {\n      // Mocking time in Jest is tricky as both requestAnimationFrame and setImmediate\n      // callbacks run on the same queue and can be interleaved. There is no way\n      // to flush particular queue in Jest and the only control over mocked timers\n      // is by using jest.advanceTimersByTime() method which advances all types\n      // of timers including immediate and animation callbacks. Ideally we'd like\n      // to have some way here to schedule work along with React updates, but\n      // that's not possible, and hence in Jest environment instead of using scheduling\n      // mechanism we just schedule the work ommiting the queue. This is ok for the\n      // uses that we currently have but may not be ok for future tests that we write.\n      NativeReanimatedModule.scheduleOnUI(\n        makeShareableCloneRecursive(() => {\n          'worklet';\n          worklet(...args);\n        })\n      );\n      return;\n    }\n    _runOnUIQueue.push([worklet, args]);\n    if (_runOnUIQueue.length === 1) {\n      setImmediate(() => {\n        const queue = _runOnUIQueue;\n        _runOnUIQueue = [];\n        NativeReanimatedModule.scheduleOnUI(\n          makeShareableCloneRecursive(() => {\n            'worklet';\n            queue.forEach(([worklet, args]) => {\n              worklet(...args);\n            });\n            flushImmediates();\n          })\n        );\n      });\n    }\n  };\n}\n\n/**\n * Schedule a worklet to execute on the UI runtime skipping batching mechanism.\n */\nexport function runOnUIImmediately<A extends any[], R>(\n  worklet: ComplexWorkletFunction<A, R>\n): (...args: A) => void {\n  if (__DEV__ && !IS_WEB && worklet.__workletHash === undefined) {\n    throw new Error('runOnUI() can only be used on worklets');\n  }\n  return (...args) => {\n    NativeReanimatedModule.scheduleOnUI(\n      makeShareableCloneRecursive(() => {\n        'worklet';\n        worklet(...args);\n      })\n    );\n  };\n}\n\nif (__DEV__) {\n  try {\n    runOnUI(() => {\n      'worklet';\n    });\n  } catch (e) {\n    throw new Error(\n      'Failed to create a worklet. Did you forget to add Reanimated Babel plugin in babel.config.js? See installation docs at https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/installation#babel-plugin.'\n    );\n  }\n}\n\nexport function runOnJS<A extends any[], R>(\n  fun: ComplexWorkletFunction<A, R>\n): (...args: A) => void {\n  'worklet';\n  if (fun.__remoteFunction) {\n    // in development mode the function provided as `fun` throws an error message\n    // such that when someone accidently calls it directly on the UI runtime, they\n    // see that they should use `runOnJS` instead. To facilitate that we purt the\n    // reference to the original remote function in the `__remoteFunction` property.\n    fun = fun.__remoteFunction;\n  }\n  if (!_WORKLET) {\n    return fun;\n  }\n  return (...args) => {\n    _scheduleOnJS(\n      fun,\n      args.length > 0 ? makeShareableCloneOnUIRecursive(args) : undefined\n    );\n  };\n}\n"]},"metadata":{},"sourceType":"module"}