{"ast":null,"code":"import { isJest } from \"./PlatformChecker\";\nimport { runOnUI } from \"./threads\";\nvar IS_JEST = isJest();\nexport function createMapperRegistry() {\n  'worklet';\n\n  var mappers = new Map();\n  var sortedMappers = [];\n  var runRequested = false;\n  function updateMappersOrder() {\n    var pre = new Map();\n    mappers.forEach(function (mapper) {\n      if (mapper.outputs) {\n        for (var output of mapper.outputs) {\n          var preMappers = pre.get(output);\n          if (preMappers === undefined) {\n            pre.set(output, [mapper]);\n          } else {\n            preMappers.push(mapper);\n          }\n        }\n      }\n    });\n    var visited = new Set();\n    var newOrder = [];\n    function dfs(mapper) {\n      visited.add(mapper);\n      for (var input of mapper.inputs) {\n        var preMappers = pre.get(input);\n        if (preMappers) {\n          for (var preMapper of preMappers) {\n            if (!visited.has(preMapper)) {\n              dfs(preMapper);\n            }\n          }\n        }\n      }\n      newOrder.push(mapper);\n    }\n    mappers.forEach(function (mapper) {\n      if (!visited.has(mapper)) {\n        dfs(mapper);\n      }\n    });\n    sortedMappers = newOrder;\n  }\n  function mapperRun() {\n    runRequested = false;\n    if (mappers.size !== sortedMappers.length) {\n      updateMappersOrder();\n    }\n    for (var mapper of sortedMappers) {\n      if (mapper.dirty) {\n        mapper.dirty = false;\n        mapper.worklet();\n      }\n    }\n  }\n  function maybeRequestUpdates() {\n    if (IS_JEST) {\n      mapperRun();\n    } else if (!runRequested) {\n      setImmediate(mapperRun);\n      runRequested = true;\n    }\n  }\n  function extractInputs(inputs, resultArray) {\n    if (Array.isArray(inputs)) {\n      for (var input of inputs) {\n        input && extractInputs(input, resultArray);\n      }\n    } else if (inputs.addListener) {\n      resultArray.push(inputs);\n    } else if (typeof inputs === 'object') {\n      for (var element of Object.values(inputs)) {\n        element && extractInputs(element, resultArray);\n      }\n    }\n    return resultArray;\n  }\n  return {\n    start: function start(mapperID, worklet, inputs, outputs) {\n      var mapper = {\n        id: mapperID,\n        dirty: true,\n        worklet: worklet,\n        inputs: extractInputs(inputs, []),\n        outputs: outputs\n      };\n      mappers.set(mapper.id, mapper);\n      sortedMappers = [];\n      for (var sv of mapper.inputs) {\n        sv.addListener(mapper.id, function () {\n          mapper.dirty = true;\n          maybeRequestUpdates();\n        });\n      }\n      maybeRequestUpdates();\n    },\n    stop: function stop(mapperID) {\n      var mapper = mappers.get(mapperID);\n      if (mapper) {\n        mappers.delete(mapper.id);\n        sortedMappers = [];\n        for (var sv of mapper.inputs) {\n          sv.removeListener(mapper.id);\n        }\n      }\n    }\n  };\n}\nvar MAPPER_ID = 9999;\nexport function startMapper(worklet) {\n  var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var outputs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var mapperID = MAPPER_ID += 1;\n  runOnUI(function () {\n    'worklet';\n\n    var mapperRegistry = global.__mapperRegistry;\n    if (mapperRegistry === undefined) {\n      mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n    }\n    mapperRegistry.start(mapperID, worklet, inputs, outputs);\n  })();\n  return mapperID;\n}\nexport function stopMapper(mapperID) {\n  runOnUI(function () {\n    'worklet';\n\n    var mapperRegistry = global.__mapperRegistry;\n    mapperRegistry === null || mapperRegistry === void 0 ? void 0 : mapperRegistry.stop(mapperID);\n  })();\n}","map":{"version":3,"mappings":"AACA,SAASA,MAAT;AACA,SAASC,OAAT;AAEA,IAAMC,OAAO,GAAGF,MAAM,EAAtB;AAUA,OAAO,SAASG,oBAAT,GAAgC;EACrC;;EACA,IAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB;EACA,IAAIC,aAAuB,GAAG,EAA9B;EAEA,IAAIC,YAAY,GAAG,KAAnB;EAEA,SAASC,kBAAT,GAA8B;IAqB5B,IAAMC,GAAG,GAAG,IAAIJ,GAAJ,EAAZ;IACAD,OAAO,CAACM,OAAR,CAAiBC,gBAAD,EAAY;MAC1B,IAAIA,MAAM,CAACC,OAAX,EAAoB;QAClB,KAAK,IAAMC,MAAX,IAAqBF,MAAM,CAACC,OAA5B,EAAqC;UACnC,IAAME,UAAU,GAAGL,GAAG,CAACM,GAAJ,CAAQF,MAAR,CAAnB;UACA,IAAIC,UAAU,KAAKE,SAAnB,EAA8B;YAC5BP,GAAG,CAACQ,GAAJ,CAAQJ,MAAR,EAAgB,CAACF,MAAD,CAAhB;UACD,CAFD,MAEO;YACLG,UAAU,CAACI,IAAX,CAAgBP,MAAhB;UACD;QACF;MACF;IACF,CAXD;IAYA,IAAMQ,OAAO,GAAG,IAAIC,GAAJ,EAAhB;IACA,IAAMC,QAAkB,GAAG,EAA3B;IACA,SAASC,GAAT,CAAaX,MAAb,EAA6B;MAC3BQ,OAAO,CAACI,GAAR,CAAYZ,MAAZ;MACA,KAAK,IAAMa,KAAX,IAAoBb,MAAM,CAACc,MAA3B,EAAmC;QACjC,IAAMX,UAAU,GAAGL,GAAG,CAACM,GAAJ,CAAQS,KAAR,CAAnB;QACA,IAAIV,UAAJ,EAAgB;UACd,KAAK,IAAMY,SAAX,IAAwBZ,UAAxB,EAAoC;YAClC,IAAI,CAACK,OAAO,CAACQ,GAAR,CAAYD,SAAZ,CAAL,EAA6B;cAC3BJ,GAAG,CAACI,SAAD,CAAH;YACD;UACF;QACF;MACF;MACDL,QAAQ,CAACH,IAAT,CAAcP,MAAd;IACD;IACDP,OAAO,CAACM,OAAR,CAAiBC,gBAAD,EAAY;MAC1B,IAAI,CAACQ,OAAO,CAACQ,GAAR,CAAYhB,MAAZ,CAAL,EAA0B;QACxBW,GAAG,CAACX,MAAD,CAAH;MACD;IACF,CAJD;IAKAL,aAAa,GAAGe,QAAhB;EACD;EAED,SAASO,SAAT,GAAqB;IACnBrB,YAAY,GAAG,KAAf;IACA,IAAIH,OAAO,CAACyB,IAAR,KAAiBvB,aAAa,CAACwB,MAAnC,EAA2C;MACzCtB,kBAAkB;IACnB;IACD,KAAK,IAAMG,MAAX,IAAqBL,aAArB,EAAoC;MAClC,IAAIK,MAAM,CAACoB,KAAX,EAAkB;QAChBpB,MAAM,CAACoB,KAAP,GAAe,KAAf;QACApB,MAAM,CAACqB,OAAP;MACD;IACF;EACF;EAED,SAASC,mBAAT,GAA+B;IAC7B,IAAI/B,OAAJ,EAAa;MAOX0B,SAAS;IACV,CARD,MAQO,IAAI,CAACrB,YAAL,EAAmB;MACxB2B,YAAY,CAACN,SAAD,CAAZ;MACArB,YAAY,GAAG,IAAf;IACD;EACF;EAED,SAAS4B,aAAT,CACEV,MADF,EAEEW,WAFF,EAGsB;IACpB,IAAIC,KAAK,CAACC,OAAN,CAAcb,MAAd,CAAJ,EAA2B;MACzB,KAAK,IAAMD,KAAX,IAAoBC,MAApB,EAA4B;QAC1BD,KAAK,IAAIW,aAAa,CAACX,KAAD,EAAQY,WAAR,CAAtB;MACD;IACF,CAJD,MAIO,IAAIX,MAAM,CAACc,WAAX,EAAwB;MAC7BH,WAAW,CAAClB,IAAZ,CAAiBO,MAAjB;IACD,CAFM,MAEA,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;MACrC,KAAK,IAAMe,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAcjB,MAAd,CAAtB,EAA6C;QAC3Ce,OAAO,IAAIL,aAAa,CAACK,OAAD,EAAUJ,WAAV,CAAxB;MACD;IACF;IACD,OAAOA,WAAP;EACD;EAED,OAAO;IACLO,KAAK,EAAE,eACLC,QADK,EAELZ,OAFK,EAGLP,MAHK,EAILb,OAJK,EAKF;MACH,IAAMD,MAAM,GAAG;QACbkC,EAAE,EAAED,QADS;QAEbb,KAAK,EAAE,IAFM;QAGbC,OAHa,EAGbA,OAHa;QAIbP,MAAM,EAAEU,aAAa,CAACV,MAAD,EAAS,EAAT,CAJR;QAKbb;MALa,CAAf;MAOAR,OAAO,CAACa,GAAR,CAAYN,MAAM,CAACkC,EAAnB,EAAuBlC,MAAvB;MACAL,aAAa,GAAG,EAAhB;MACA,KAAK,IAAMwC,EAAX,IAAiBnC,MAAM,CAACc,MAAxB,EAAgC;QAC9BqB,EAAE,CAACP,WAAH,CAAe5B,MAAM,CAACkC,EAAtB,EAA0B,YAAM;UAC9BlC,MAAM,CAACoB,KAAP,GAAe,IAAf;UACAE,mBAAmB;QACpB,CAHD;MAID;MACDA,mBAAmB;IACpB,CAvBI;IAwBLc,IAAI,EAAGH,sBAAD,EAAsB;MAC1B,IAAMjC,MAAM,GAAGP,OAAO,CAACW,GAAR,CAAY6B,QAAZ,CAAf;MACA,IAAIjC,MAAJ,EAAY;QACVP,OAAO,CAAC4C,MAAR,CAAerC,MAAM,CAACkC,EAAtB;QACAvC,aAAa,GAAG,EAAhB;QACA,KAAK,IAAMwC,EAAX,IAAiBnC,MAAM,CAACc,MAAxB,EAAgC;UAC9BqB,EAAE,CAACG,cAAH,CAAkBtC,MAAM,CAACkC,EAAzB;QACD;MACF;IACF;EAjCI,CAAP;AAmCD;AAED,IAAIK,SAAS,GAAG,IAAhB;AAEA,OAAO,SAASC,WAAT,CACLnB,OADK,EAIG;EAAA,IAFRP,MAEQ,uEAFQ,EAER;EAAA,IADRb,OACQ,uEADS,EACT;EACR,IAAMgC,QAAQ,GAAIM,SAAS,IAAI,CAA/B;EAEAjD,OAAO,CAAC,YAAM;IACZ;;IACA,IAAImD,cAAc,GAAGC,MAAM,CAACC,gBAA5B;IACA,IAAIF,cAAc,KAAKpC,SAAvB,EAAkC;MAChCoC,cAAc,GAAGC,MAAM,CAACC,gBAAP,GAA0BnD,oBAAoB,EAA/D;IACD;IACDiD,cAAc,CAACT,KAAf,CAAqBC,QAArB,EAA+BZ,OAA/B,EAAwCP,MAAxC,EAAgDb,OAAhD;EACD,CAPM,CAAP;EASA,OAAOgC,QAAP;AACD;AAED,OAAO,SAASW,UAAT,CAAoBX,QAApB,EAA4C;EACjD3C,OAAO,CAAC,YAAM;IACZ;;IACA,IAAMmD,cAAc,GAAGC,MAAM,CAACC,gBAA9B;IACAF,cAAc,SAAd,kBAAc,WAAd,0BAAc,CAAEL,IAAhB,CAAqBH,QAArB;EACD,CAJM,CAAP;AAKD","names":["isJest","runOnUI","IS_JEST","createMapperRegistry","mappers","Map","sortedMappers","runRequested","updateMappersOrder","pre","forEach","mapper","outputs","output","preMappers","get","undefined","set","push","visited","Set","newOrder","dfs","add","input","inputs","preMapper","has","mapperRun","size","length","dirty","worklet","maybeRequestUpdates","setImmediate","extractInputs","resultArray","Array","isArray","addListener","element","Object","values","start","mapperID","id","sv","stop","delete","removeListener","MAPPER_ID","startMapper","mapperRegistry","global","__mapperRegistry","stopMapper"],"sources":["mappers.ts"],"sourcesContent":["import { SharedValue } from './commonTypes';\nimport { isJest } from './PlatformChecker';\nimport { runOnUI } from './threads';\n\nconst IS_JEST = isJest();\n\nexport type Mapper = {\n  id: number;\n  dirty: boolean;\n  worklet: () => void;\n  inputs: SharedValue<any>[];\n  outputs?: SharedValue<any>[];\n};\n\nexport function createMapperRegistry() {\n  'worklet';\n  const mappers = new Map();\n  let sortedMappers: Mapper[] = [];\n\n  let runRequested = false;\n\n  function updateMappersOrder() {\n    // sort mappers topologically\n    // the algorithm here takes adventage of a fact that the topological order\n    // of a transposed graph is a reverse topological order of the original graph\n    // The graph in our case consists of mappers and an edge between two mappers\n    // A and B exists if there is a shared value that's on A's output lists and on\n    // B's input list.\n    //\n    // We don't need however to calculate that graph as it is easier to work with\n    // the transposed version of it that can be calculated ad-hoc. For the transposed\n    // version to be traversed we use \"pre\" map that maps share value to mappers that\n    // output that shared value. Then we can infer all the outgoing edges for a given\n    // mapper simply by scanning it's input list and checking if any of the shared values\n    // from that list exists in the \"pre\" map. If they do, then we have an edge between\n    // that mapper and the mappers from the \"pre\" list for the given shared value.\n    //\n    // For topological sorting we use a dfs-based approach that requires the graph to\n    // be traversed in dfs order and each node after being processed lands at the\n    // beginning of the topological order list. Since we traverse a transposed graph,\n    // instead of reversing that order we can use a normal array and push processed\n    // mappers to the end. There is no need to reverse that array after we are done.\n    const pre = new Map(); // map from sv -> mapper that outputs that sv\n    mappers.forEach((mapper) => {\n      if (mapper.outputs) {\n        for (const output of mapper.outputs) {\n          const preMappers = pre.get(output);\n          if (preMappers === undefined) {\n            pre.set(output, [mapper]);\n          } else {\n            preMappers.push(mapper);\n          }\n        }\n      }\n    });\n    const visited = new Set();\n    const newOrder: Mapper[] = [];\n    function dfs(mapper: Mapper) {\n      visited.add(mapper);\n      for (const input of mapper.inputs) {\n        const preMappers = pre.get(input);\n        if (preMappers) {\n          for (const preMapper of preMappers) {\n            if (!visited.has(preMapper)) {\n              dfs(preMapper);\n            }\n          }\n        }\n      }\n      newOrder.push(mapper);\n    }\n    mappers.forEach((mapper) => {\n      if (!visited.has(mapper)) {\n        dfs(mapper);\n      }\n    });\n    sortedMappers = newOrder;\n  }\n\n  function mapperRun() {\n    runRequested = false;\n    if (mappers.size !== sortedMappers.length) {\n      updateMappersOrder();\n    }\n    for (const mapper of sortedMappers) {\n      if (mapper.dirty) {\n        mapper.dirty = false;\n        mapper.worklet();\n      }\n    }\n  }\n\n  function maybeRequestUpdates() {\n    if (IS_JEST) {\n      // On Jest environment we avoid using setImmediate as that'd require test\n      // to advance the clock manually. This on other hand would require tests\n      // to know how many times mappers need to run. As we don't want tests to\n      // make any assumptions on that number it is easier to execute mappers\n      // immediately for testing purposes and only expect test to advance timers\n      // if they want to make any assertions on the effects of animations being run.\n      mapperRun();\n    } else if (!runRequested) {\n      setImmediate(mapperRun);\n      runRequested = true;\n    }\n  }\n\n  function extractInputs(\n    inputs: any,\n    resultArray: SharedValue<any>[]\n  ): SharedValue<any>[] {\n    if (Array.isArray(inputs)) {\n      for (const input of inputs) {\n        input && extractInputs(input, resultArray);\n      }\n    } else if (inputs.addListener) {\n      resultArray.push(inputs);\n    } else if (typeof inputs === 'object') {\n      for (const element of Object.values(inputs)) {\n        element && extractInputs(element, resultArray);\n      }\n    }\n    return resultArray;\n  }\n\n  return {\n    start: (\n      mapperID: number,\n      worklet: () => void,\n      inputs: SharedValue<any>[],\n      outputs?: SharedValue<any>[]\n    ) => {\n      const mapper = {\n        id: mapperID,\n        dirty: true,\n        worklet,\n        inputs: extractInputs(inputs, []),\n        outputs,\n      };\n      mappers.set(mapper.id, mapper);\n      sortedMappers = [];\n      for (const sv of mapper.inputs) {\n        sv.addListener(mapper.id, () => {\n          mapper.dirty = true;\n          maybeRequestUpdates();\n        });\n      }\n      maybeRequestUpdates();\n    },\n    stop: (mapperID: number) => {\n      const mapper = mappers.get(mapperID);\n      if (mapper) {\n        mappers.delete(mapper.id);\n        sortedMappers = [];\n        for (const sv of mapper.inputs) {\n          sv.removeListener(mapper.id);\n        }\n      }\n    },\n  };\n}\n\nlet MAPPER_ID = 9999;\n\nexport function startMapper(\n  worklet: () => void,\n  inputs: any[] = [],\n  outputs: any[] = []\n): number {\n  const mapperID = (MAPPER_ID += 1);\n\n  runOnUI(() => {\n    'worklet';\n    let mapperRegistry = global.__mapperRegistry;\n    if (mapperRegistry === undefined) {\n      mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n    }\n    mapperRegistry.start(mapperID, worklet, inputs, outputs);\n  })();\n\n  return mapperID;\n}\n\nexport function stopMapper(mapperID: number): void {\n  runOnUI(() => {\n    'worklet';\n    const mapperRegistry = global.__mapperRegistry;\n    mapperRegistry?.stop(mapperID);\n  })();\n}\n"]},"metadata":{},"sourceType":"module"}