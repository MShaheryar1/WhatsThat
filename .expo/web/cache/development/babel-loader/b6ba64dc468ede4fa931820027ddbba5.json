{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _workletStackDetails = new Map();\nexport function registerWorkletStackDetails(hash, stackDetails) {\n  _workletStackDetails.set(hash, stackDetails);\n}\nfunction getBundleOffset(error) {\n  var _error$stack, _error$stack$split;\n  var frame = (_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : (_error$stack$split = _error$stack.split('\\n')) === null || _error$stack$split === void 0 ? void 0 : _error$stack$split[0];\n  if (frame) {\n    var parsedFrame = /@([^@]+):(\\d+):(\\d+)/.exec(frame);\n    if (parsedFrame) {\n      var _parsedFrame = _slicedToArray(parsedFrame, 4),\n        file = _parsedFrame[1],\n        line = _parsedFrame[2],\n        col = _parsedFrame[3];\n      return [file, Number(line), Number(col)];\n    }\n  }\n  return ['unknown', 0, 0];\n}\nfunction processStack(stack) {\n  var workletStackEntries = stack.match(/worklet_(\\d+):(\\d+):(\\d+)/g);\n  var result = stack;\n  workletStackEntries === null || workletStackEntries === void 0 ? void 0 : workletStackEntries.forEach(function (match) {\n    var _match$split$map = match.split(/:|_/).map(Number),\n      _match$split$map2 = _slicedToArray(_match$split$map, 4),\n      hash = _match$split$map2[1],\n      origLine = _match$split$map2[2],\n      origCol = _match$split$map2[3];\n    var errorDetails = _workletStackDetails.get(hash);\n    if (!errorDetails) {\n      return;\n    }\n    var _errorDetails = _slicedToArray(errorDetails, 3),\n      error = _errorDetails[0],\n      lineOffset = _errorDetails[1],\n      colOffset = _errorDetails[2];\n    var _getBundleOffset = getBundleOffset(error),\n      _getBundleOffset2 = _slicedToArray(_getBundleOffset, 3),\n      bundleFile = _getBundleOffset2[0],\n      bundleLine = _getBundleOffset2[1],\n      bundleCol = _getBundleOffset2[2];\n    var line = origLine + bundleLine + lineOffset;\n    var col = origCol + bundleCol + colOffset;\n    result = result.replace(match, bundleFile + \":\" + line + \":\" + col);\n  });\n  return result;\n}\nexport function reportFatalErrorOnJS(_ref) {\n  var message = _ref.message,\n    stack = _ref.stack;\n  var error = new Error();\n  error.message = message;\n  error.stack = stack ? processStack(stack) : undefined;\n  error.name = 'ReanimatedError';\n  error.jsEngine = 'reanimated';\n  global.ErrorUtils.reportFatalError(error);\n}","map":{"version":3,"mappings":";AAEA,IAAMA,oBAAoB,GAAG,IAAIC,GAAJ,EAA7B;AAEA,OAAO,SAASC,2BAAT,CACLC,IADK,EAELC,YAFK,EAGL;EACAJ,oBAAoB,CAACK,GAArB,CAAyBF,IAAzB,EAA+BC,YAA/B;AACD;AAED,SAASE,eAAT,CAAyBC,KAAzB,EAAiE;EAAA;EAC/D,IAAMC,KAAK,mBAAGD,KAAK,CAACE,KAAT,uEAAGC,aAAaC,KAAb,CAAmB,IAAnB,CAAH,uDAAGC,mBAA2B,CAA3B,CAAd;EACA,IAAIJ,KAAJ,EAAW;IACT,IAAMK,WAAW,GAAG,uBAAuBC,IAAvB,CAA4BN,KAA5B,CAApB;IACA,IAAIK,WAAJ,EAAiB;MACf,kCAA4BA,WAA5B;QAASE,IAAH;QAASC,IAAT;QAAeC,GAAf;MACN,OAAO,CAACF,IAAD,EAAOG,MAAM,CAACF,IAAD,CAAb,EAAqBE,MAAM,CAACD,GAAD,CAA3B,CAAP;IACD;EACF;EACD,OAAO,CAAC,SAAD,EAAY,CAAZ,EAAe,CAAf,CAAP;AACD;AAED,SAASE,YAAT,CAAsBV,KAAtB,EAA6C;EAC3C,IAAMW,mBAAmB,GAAGX,KAAK,CAACY,KAAN,CAAY,4BAAZ,CAA5B;EACA,IAAIC,MAAM,GAAGb,KAAb;EACAW,mBAAmB,SAAnB,uBAAmB,WAAnB,+BAAmB,CAAEG,OAArB,CAA8BF,eAAD,EAAW;IACtC,uBAAoCA,KAAK,CAACV,KAAN,CAAY,KAAZ,EAAmBa,GAAnB,CAAuBN,MAAvB,CAApC;MAAA;MAASf,IAAH;MAASsB,QAAT;MAAmBC,OAAnB;IACN,IAAMC,YAAY,GAAG3B,oBAAoB,CAAC4B,GAArB,CAAyBzB,IAAzB,CAArB;IACA,IAAI,CAACwB,YAAL,EAAmB;MACjB;IACD;IACD,mCAAuCA,YAAvC;MAAOpB,KAAD;MAAQsB,UAAR;MAAoBC,SAApB;IACN,uBAA4CxB,eAAe,CAACC,KAAD,CAA3D;MAAA;MAAOwB,UAAD;MAAaC,UAAb;MAAyBC,SAAzB;IACN,IAAMjB,IAAI,GAAGS,QAAQ,GAAGO,UAAX,GAAwBH,UAArC;IACA,IAAMZ,GAAG,GAAGS,OAAO,GAAGO,SAAV,GAAsBH,SAAlC;IAEAR,MAAM,GAAGA,MAAM,CAACY,OAAP,CAAeb,KAAf,EAAyBU,UAAW,SAAGf,IAAK,SAAGC,GAAI,CAA5D;EACD,CAZD;EAaA,OAAOK,MAAP;AACD;AAED,OAAO,SAASa,oBAAT,OAMJ;EAAA,IALDC,OADmC,GAMlCC,KALDD,OADmC;IAEnC3B,QAIC4B,KAJD5B;EAKA,IAAMF,KAAK,GAAG,IAAI+B,KAAJ,EAAd;EACA/B,KAAK,CAAC6B,OAAN,GAAgBA,OAAhB;EACA7B,KAAK,CAACE,KAAN,GAAcA,KAAK,GAAGU,YAAY,CAACV,KAAD,CAAf,GAAyB8B,SAA5C;EACAhC,KAAK,CAACiC,IAAN,GAAa,iBAAb;EAEAjC,KAAK,CAACkC,QAAN,GAAiB,YAAjB;EACAC,MAAM,CAACC,UAAP,CAAkBC,gBAAlB,CAAmCrC,KAAnC;AACD","names":["_workletStackDetails","Map","registerWorkletStackDetails","hash","stackDetails","set","getBundleOffset","error","frame","stack","_error$stack","split","_error$stack$split","parsedFrame","exec","file","line","col","Number","processStack","workletStackEntries","match","result","forEach","map","origLine","origCol","errorDetails","get","lineOffset","colOffset","bundleFile","bundleLine","bundleCol","replace","reportFatalErrorOnJS","message","_ref","Error","undefined","name","jsEngine","global","ErrorUtils","reportFatalError"],"sources":["errors.ts"],"sourcesContent":["type StackDetails = [Error, number, number];\n\nconst _workletStackDetails = new Map<number, StackDetails>();\n\nexport function registerWorkletStackDetails(\n  hash: number,\n  stackDetails: StackDetails\n) {\n  _workletStackDetails.set(hash, stackDetails);\n}\n\nfunction getBundleOffset(error: Error): [string, number, number] {\n  const frame = error.stack?.split('\\n')?.[0];\n  if (frame) {\n    const parsedFrame = /@([^@]+):(\\d+):(\\d+)/.exec(frame);\n    if (parsedFrame) {\n      const [, file, line, col] = parsedFrame;\n      return [file, Number(line), Number(col)];\n    }\n  }\n  return ['unknown', 0, 0];\n}\n\nfunction processStack(stack: string): string {\n  const workletStackEntries = stack.match(/worklet_(\\d+):(\\d+):(\\d+)/g);\n  let result = stack;\n  workletStackEntries?.forEach((match) => {\n    const [, hash, origLine, origCol] = match.split(/:|_/).map(Number);\n    const errorDetails = _workletStackDetails.get(hash);\n    if (!errorDetails) {\n      return;\n    }\n    const [error, lineOffset, colOffset] = errorDetails;\n    const [bundleFile, bundleLine, bundleCol] = getBundleOffset(error);\n    const line = origLine + bundleLine + lineOffset;\n    const col = origCol + bundleCol + colOffset;\n\n    result = result.replace(match, `${bundleFile}:${line}:${col}`);\n  });\n  return result;\n}\n\nexport function reportFatalErrorOnJS({\n  message,\n  stack,\n}: {\n  message: string;\n  stack?: string;\n}) {\n  const error = new Error();\n  error.message = message;\n  error.stack = stack ? processStack(stack) : undefined;\n  error.name = 'ReanimatedError';\n  // @ts-ignore React Native's ErrorUtils implementation extends the Error type with jsEngine field\n  error.jsEngine = 'reanimated';\n  global.ErrorUtils.reportFatalError(error);\n}\n"]},"metadata":{},"sourceType":"module"}