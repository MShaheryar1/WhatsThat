{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as React from 'react';\nimport { getStateFromPath as getStateFromPathDefault, getPathFromState as getPathFromStateDefault, getActionFromState } from '@react-navigation/core';\nvar getStateLength = function getStateLength(state) {\n  var length = 0;\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n  var focusedState = state.routes[state.index].state;\n  if (focusedState && !focusedState.stale) {\n    length += getStateLength(focusedState) - 1;\n  }\n  return length;\n};\nvar isUsingLinking = false;\nexport default function useLinking(ref, _ref) {\n  var config = _ref.config,\n    _ref$getStateFromPath = _ref.getStateFromPath,\n    getStateFromPath = _ref$getStateFromPath === void 0 ? getStateFromPathDefault : _ref$getStateFromPath,\n    _ref$getPathFromState = _ref.getPathFromState,\n    getPathFromState = _ref$getPathFromState === void 0 ? getPathFromStateDefault : _ref$getPathFromState;\n  React.useEffect(function () {\n    if (isUsingLinking) {\n      throw new Error(\"Looks like you are using 'useLinking' in multiple components. This is likely an error since URL integration should only be handled in one place to avoid conflicts.\");\n    } else {\n      isUsingLinking = true;\n    }\n    return function () {\n      isUsingLinking = false;\n    };\n  });\n  var configRef = React.useRef(config);\n  var getStateFromPathRef = React.useRef(getStateFromPath);\n  var getPathFromStateRef = React.useRef(getPathFromState);\n  React.useEffect(function () {\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, getPathFromState, getStateFromPath]);\n  var getInitialState = React.useCallback(_asyncToGenerator(function* () {\n    var path = location.pathname + location.search;\n    if (path) {\n      return getStateFromPathRef.current(path, configRef.current);\n    } else {\n      return undefined;\n    }\n  }), []);\n  var previousStateLengthRef = React.useRef(undefined);\n  var previousHistoryIndexRef = React.useRef(0);\n  var pendingIndexChangeRef = React.useRef();\n  var pendingStateUpdateRef = React.useRef(false);\n  var pendingStateMultiUpdateRef = React.useRef(false);\n  var numberOfIndicesAhead = React.useRef(0);\n  React.useEffect(function () {\n    window.addEventListener('popstate', function () {\n      var _ref2, _history$state;\n      var navigation = ref.current;\n      if (!navigation) {\n        return;\n      }\n      var previousHistoryIndex = previousHistoryIndexRef.current;\n      var historyIndex = (_ref2 = (_history$state = history.state) === null || _history$state === void 0 ? void 0 : _history$state.index) !== null && _ref2 !== void 0 ? _ref2 : 0;\n      previousHistoryIndexRef.current = historyIndex;\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n      var state = navigation.getRootState();\n      var path = getPathFromStateRef.current(state, configRef.current);\n      var canGoBack = true;\n      var numberOfBacks = 0;\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({\n            index: historyIndex\n          }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks = previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n          pendingStateUpdateRef.current = true;\n          for (var i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current = historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n        var _state = getStateFromPathRef.current(location.pathname + location.search, configRef.current);\n        pendingStateMultiUpdateRef.current = true;\n        if (_state) {\n          var action = getActionFromState(_state);\n          pendingStateUpdateRef.current = true;\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(_state);\n          }\n        }\n      }\n    });\n  }, [ref]);\n  React.useEffect(function () {\n    var _ref$current;\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(ref.current.getRootState());\n    }\n    if (ref.current && location.pathname + location.search === '/') {\n      var _ref3, _history$state2;\n      history.replaceState({\n        index: (_ref3 = (_history$state2 = history.state) === null || _history$state2 === void 0 ? void 0 : _history$state2.index) !== null && _ref3 !== void 0 ? _ref3 : 0\n      }, '', getPathFromStateRef.current(ref.current.getRootState(), configRef.current));\n    }\n    var unsubscribe = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.addListener('state', function () {\n      var _previousStateLengthR, _ref4, _history$state3;\n      var navigation = ref.current;\n      if (!navigation) {\n        return;\n      }\n      var state = navigation.getRootState();\n      var path = getPathFromStateRef.current(state, configRef.current);\n      var previousStateLength = (_previousStateLengthR = previousStateLengthRef.current) !== null && _previousStateLengthR !== void 0 ? _previousStateLengthR : 1;\n      var stateLength = getStateLength(state);\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n      previousStateLengthRef.current = stateLength;\n      if (pendingStateUpdateRef.current && location.pathname + location.search === path) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n      var index = (_ref4 = (_history$state3 = history.state) === null || _history$state3 === void 0 ? void 0 : _history$state3.index) !== null && _ref4 !== void 0 ? _ref4 : 0;\n      if (previousStateLength === stateLength) {\n        if (location.pathname + location.search !== path) {\n          history.replaceState({\n            index: index\n          }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        for (var i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({\n            index: index\n          }, '', path);\n        }\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        var delta = previousStateLength - stateLength;\n        pendingIndexChangeRef.current = index - delta;\n        history.go(-delta);\n      }\n    });\n    return unsubscribe;\n  });\n  return {\n    getInitialState: getInitialState\n  };\n}","map":{"version":3,"mappings":"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","names":["React","getStateFromPath","getStateFromPathDefault","getPathFromState","getPathFromStateDefault","getActionFromState","getStateLength","state","length","history","index","focusedState","routes","stale","isUsingLinking","useLinking","ref","config","_ref","useEffect","Error","configRef","useRef","getStateFromPathRef","getPathFromStateRef","current","getInitialState","useCallback","path","location","pathname","search","undefined","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","window","addEventListener","navigation","previousHistoryIndex","historyIndex","_history$state","getRootState","canGoBack","numberOfBacks","replaceState","i","goBack","action","dispatch","resetRoot","_history$state2","unsubscribe","_ref$current","addListener","previousStateLength","stateLength","_history$state3","l","pushState","delta","go"],"sources":["useLinking.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (isUsingLinking) {\n      throw new Error(\n        \"Looks like you are using 'useLinking' in multiple components. This is likely an error since URL integration should only be handled in one place to avoid conflicts.\"\n      );\n    } else {\n      isUsingLinking = true;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, getPathFromState, getStateFromPath]);\n\n  // Make it an async function to keep consistent with the native impl\n  const getInitialState = React.useCallback(async () => {\n    const path = location.pathname + location.search;\n\n    if (path) {\n      return getStateFromPathRef.current(path, configRef.current);\n    } else {\n      return undefined;\n    }\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    window.addEventListener('popstate', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    });\n  }, [ref]);\n\n  React.useEffect(() => {\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new enrties were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new enrties were added, pushState until we have same length\n        // This won't be accurate if multiple enrties were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = previousStateLength - stateLength;\n\n        // We need to set this to ignore the `popstate` event\n        pendingIndexChangeRef.current = index - delta;\n\n        // If new enrties were removed, go back so that we have same length\n        history.go(-delta);\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}